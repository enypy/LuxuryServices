<!-- 02.02.18 -->

<link href="style.css" rel="stylesheet" type="text/css">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />

<center style="padding: 10px">
<img src="cl_logo.bmp" align=center><br>

Справка по языку сценариев актуальна для версии 4.13.014<br>Дата последней ревизии справки: 24.04.2018<br>
Если вы нашли ошибку в справке, то пишите на <a href="mailto:clickermann@inbox.ru">clickermann@inbox.ru</a>
</center>

<p class="title">Содержание</p>

<ul>
<li><a href=#HOW>КАК ЧИТАТЬ СПРАВКУ</a>
<li><a href=#LANG>ОПИСАНИЕ ЯЗЫКА СЦЕНАРИЕВ</a>
<li><a href=#VAR>ПЕРЕМЕННЫЕ И ТИПЫ ДАННЫХ</a>
<li><a href=#PROC>ПРОЦЕДУРЫ И ФУНКЦИИ</a>
<li><a href=#MATH>МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ</a>
<li><a href=#LOGIC>УСЛОВИЯ, СРАВНЕНИЯ, ЛОГИЧЕСКИЕ ОПЕРАЦИИ</a>
<li><a href=#ARRAY>МАССИВЫ</a>
<li><a href=#CONST>КОНСТАНТЫ</a>
<li><a href=#PREP>ДИРЕКТИВЫ ПРЕПРОЦЕССОРА</a>
<li><a href=#EX>ПРОЧИЕ ОСОБЕННОСТИ</a>
</ul>



<a name="HOW"></a><p class="subtitle">КАК ЧИТАТЬ СПРАВКУ</p>
<p>
Справка исполнения в формате CHM. Доступ к основным разделам осуществляется из меню слева на вкладке <b>Содержание</b>. Справка имеет поиск по перечню описанных процедур и функций. Для доступка к перечню перейдите на вкладку <b>Указатель</b>.<br>
При описании синтаксиса процедуры или функции:<br>
- <i class="par_num">Синий цвет</i> параметра означает что процедура или функция принимает численный параметр<br>
- <i class="par_str">Фиолетовый цвет</i> параметра означает что процедура или функция принимает строковый параметр<br>
- Во всех прочих случаях см. описание и пример<br>
- Квадратные скобки <b>[ ]</b> обозначают что параметр необязателен и если он опущен то будет использоваться значение по умолчанию (см. примечания)<br>
- Троеточие <b>...</b> означает что количество параметров неограничено, при этом их смысл соответствует предыдущему описанному параметру<br>
</p>




<a name="LANG"></a><p class="subtitle">ОПИСАНИЕ ЯЗЫКА СЦЕНАРИЕВ</p>
<p>
Кликер использует собственный язык программирования, созданный специально максимально дружелюбным для неподготовленного пользователя. При этом в нем присутствует практически полный набор средств для решения всевозможных алгоритмических задач. В языке присутствуют: процедуры и функции, арифметические операции и вычисления, переменые и массивы, численные и строковые типы данных, логические конструкции (условия, циклы).
<br>
Сценарий состоит из последовательности строк, которая выполняется сверху вниз (если смотреть в Редакторе). Каждая строка сценария может содержать:<br>
- Вызов процедуры<br>
- Операцию присвоения<br>
- Комментарий<br>
- Различные служебные директивы<br>
- Пустую строку (ничего не содержать)<br>
</p>
<p>
Основой любого сценария являются процедуры. Это команды кликеру выполнить какое либо действие. На одной строке сценария может находится только одна команда. При этом в качестве параметров процедуры могут выступать как просто числа, так и переменные или функции. Рассмотрим пример простейшего сценария, щелкающего мышкой каждую секунду. Описание всех приводимых в примерах процедур и функций есть в данной справке.
</p>

<b>Пример #1</b>
<pre>
// щелчек мышью
lclick(100, 200)

// пауза 1 сек
wait(1)
</pre>

<p>
Первая строка данного примера содержит комментарий, дающий пояснение, что следующая команда на строке ниже осуществляет щелчек. Вторая строка содержит вызов процедуры <b class="func_name">lclick</b>() с параметрами 100 и 200. Эта команда осуществляет щелчек левой кнопкой мыши в данные координаты на экране. Третья строка не содержит ничего (пустая строка) и служит лишь для удобства восприятия написанного кода. Четвертая строка - снова комментарий с пояснением. И, наконец, пятая строка содержит вызов процедуры <b class="func_name">wait</b>() с параметром 1, что означает временную задержку выполнения на 1 секунду. После завершения последней команды данного примера, выполнение вновь начнется с первой строки.<br>
Как видно из описания, фактически сценарий имеет всего две функциональные строки, содержащий действия. Остальные же строки служат исключительно для удобства восприятия сценария и не выполняют каких-либо действий.
</p>





<a name="VAR"></a><p class="subtitle">ПЕРЕМЕННЫЕ И ТИПЫ ДАННЫХ</p>
<p>
Что такое переменные, вы прекрасно знаете со школы. Это такие ячейки (в нашем случае памяти), имеющие собственное уникальное имя и содержащие некие данные. При этом переменные могут использоваться в качестве параметров или аргументов выражений. Результат таких действий будет зависить от того, какое конкретное значение в момент обращения содержит переменная.<br>
Имена переменные в кликере всегда начинаются со знака <i class="par_var">$</i> ("доллар") после которых идет уникальное имя переменной. Допустимыми символами для имени являются цифры <i class="par_var">0..9</i>, символы латинского алфавита <i class="par_var">a..z</i> и знак "<i class="par_var">_</i>" (нижняя черта). Таким образом, целиком имя переменной может выглядеть как <i class="par_var">$var1</i> или <i class="par_var">$total_sum</i>.<br>
Перепишем Пример #1 используя полученные знания. Введем счетчик осуществленных щелчков и его вывод.
</p>

<b>Пример #2</b>
<pre>
// щелчек мышью
lclick(100, 200)

// пауза 1 сек
wait(1)

// Увеличение переменной-счетчика
$count = $count + 1

// Вывод сообщения
print("Щелчков: ", $count)
</pre>

<p>
Добавилось несколько строк. С первыми строками вы уже знакомы. Переходим сразу к восьмой строке. Здесь содержится присвоение значения переменной и ее увеличение путем прибавления к ее текущему значению единицы. В самый первый прогон скрипта счетчик равен 0. Так ведет себя любая переменная, которой еще не было присвоено значение, но к которой обратились. Затем к этому значению прибавляется 1 и результат вычисления правой части выражения присваивается той же переменной, обновляя ее значение. Подробнее про вычисления смотрите в соответствующем разделе ниже.<br>
Одиннадцатая строка интереснее. Она содержит процедуру <b class="func_name">print</b>(), которая выводит строку параметров в окно лога. Строка образуется путем "склеивания" параметров. Первым параметром идет строка <i class="par_str">"Щелчков: "</i>, которая служит пояснением. Второй параметр - счетчик кликов <i class="par_var">$count</i>. Поскольку при обработке параметра будет извлечено значение переменной <i class="par_var">$count</i>, то в конечном итоге процедура <b class="func_name">print</b>() при каждом повторе сценария будет выводить строки следующего вида: <i class="par_str">"Щелчков: 0"</i>, <i class="par_str">"Щелчков: 1"</i>, и т.д.<br>
Проще говоря, код в кавычках являются строкой (строковый тип данных) и не подлежат обработке, даже если строка содержит имя переменной или арифметические операции. Все прочие данные (числа, переменные и пр.) кликер пытается обработать (выполнить, вычислить). Поэтому инструкция вида

<pre>
print("$count = ", $count)
</pre>
в итоге выдаст в лог строку <i class="par_str">"$count = 0"</i>. Собственно, это основная разница между типами данных. Численные - вычисляются, строковые - нет. При этом переменная, которая содержит строку или результат выполнения строковой функции, считается строкового типа, а переменная аналогичным образом содержащая число - числового типа. <!-- При взаимодействии разнотипных данных возникает один момент, приведенный в разделе <a href=#EX>ПРОЧИЕ ОСОБЕННОСТИ</a>, к которому вам рекомендуется вернуться после прочтения всего этого вводного материала. -->
</p>


<p>
Так же стоит отметить ряд служебных переменных, их имена зарезервированы самой программой, а значения помещаются в них автоматически при обращении к ним. При этом присваивать этим переменным какие либо значения крайне не рекомендуется во избежание ошибок. Используйте их только для получения значений. В таблице #1 приведен полный список служебных переменных и их описание.

<br><br>

<b>Таблица #1 - Перечень служебных переменных</b><br>
</p>

<table border=1 cellspacing=0 cellpadding=3>
<tr><td>Имя переменной</td><td>Значение</td></tr>
<tr><td>$_xmouse</td><td>Текущие координаты мыши по оси Х</td></tr>
<tr><td>$_ymouse</td><td>Текущие координаты мыши по оси Y</td></tr>
<tr><td>$_xmax</td><td>Максимально допустимое значение X, вычисляется из конфигурации рабочего стола</td></tr>
<tr><td>$_ymax</td><td>Максимально допустимое значение Y, (..)</td></tr>
<tr><td>$_xmin</td><td>Минимально допустимое значение X, (..)</td></tr>
<tr><td>$_ymin</td><td>Минимально допустимое значение Y, (..)</td></tr>
<tr><td>$_return1</td><td>Используется для возврата в нее значения определенными инструкциями</td></tr>
<tr><td>$_return2</td><td>Аналогично</td></tr>
<tr><td>$_cursor</td><td>Текущий вид указателя мыши (стрелка, палец и т.п.)</td></tr>
<tr><td>$_ms</td><td>Системный таймер Windows, отсчитывающий миллисекунды с момента старта ОС</td></tr>
<tr><td>$_time_t</td><td>Текущее время в формате Unix-систем (<a href="http://ru.wikipedia.org/wiki/Epoch" target=_blank>подробнее</a>)</td></tr>
<tr><td>$_time_h</td><td>Текущий час</td></tr>
<tr><td>$_time_m</td><td>Текущая минута</td></tr>
<tr><td>$_time_s</td><td>Текущая секунда</td></tr>
<tr><td>$_date_y</td><td>Текущий год</td></tr>
<tr><td>$_date_m</td><td>Текущий месяц</td></tr>
<tr><td>$_date_d</td><td>Текущие число</td></tr>
<tr><td>$_time_str</td><td>Текущие время</td></tr>
<tr><td>$_date_str</td><td>Текущая дата</td></tr>
<tr><td>$_hwnd</td><td>Текущий hwnd привязки (если 0, то привязки к окну нет)</td></tr>
<tr><td>$_hwnd_self</td><td>Собственный hwnd кликера</td></tr>
<tr><td>$_pdir</td><td>Текущая рабочая директория</td></tr>
<tr><td>$_ver_self</td><td>Версия программы</td></tr>
<tr><td>$_ver_sys</td><td>Версия системы</td></tr>
<tr><td>$_arch_sys</td><td>Разрядность системы</td></tr>
<tr><td>$_param_str</td><td>Параметры запуска программы, разделенные ";"</td></tr>
</table>


<a name="PROC"></a><p class="subtitle">ПРОЦЕДУРЫ И ФУНКЦИИ</p>
<p>
Что такое процедуры вы уже знаете (см. Пример #1). Типичная процедура это <b class="func_name">lclick</b>(<i class="par_num">x</i>, <i class="par_num">y</i>). Где <b class="func_name">lclick</b> - это имя процедуры, а в скобках указаны ее параметры: <i class="par_num">x</i> и <i class="par_num">y</i>.<br>
Функции, как и процедуры, так же имеют свои собственные имена и набор параметров. При этом, функция, по аналогии с переменной, возвращает свое значение в то место, где она была вызвана.<br>
Перепишем Пример #2 и введем функцию, возвращающую случайное число. 
</p>

<b>Пример #3</b>
<pre>
// щелчек мышью
lclick( rnd(50, 100) + 50, rnd(50, 100) + 50 )

// случайная пауза от 1 до 5 сек
wait( rnd(3, 5) )

// Увеличение переменной-счетчика
$count = $count + 1

// Вывод сообщения
print("Щелчков: ", $count)
</pre>

<p>
Мы изменили вторую строчку таким образом, что щелчек теперь осуществляется в случайные координаты. Параметры <i class="par_num">x</i> и <i class="par_num">y</i> теперь принимают значения от 100 до 150. Это достигается использованием функции <b class="func_name">rnd</b>(), которая возвращает значение от 50 до 100, к которому в свою очередь затем прибавляется 50. Точно так же на пятой строчке достигается случайная временная задержка от 3 до 5 секунд.<br>
Таким образом, как вы видите, функции могут использоваться как самостоятельно в качестве параметров, так и в качестве участников выражения. В данной справке в описании всегда указывается является инструкция процедурой или функцией.
</p>



<a name="MATH"></a><p class="subtitle">МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ</p>
<p>
Вычисления являются важной частью составления алгоритмов. Кликер поддерживает все базовые математические операции. Правила вычислений соответствуют общепринятым нормам, поэтому вас не возникнет проблем в составлении выражений. К тому же в предыдущих примерах вы уж видели использование такой операции, как сложение.<br>
Производить вычисления можно как при присвоении переменной какого-либо значения, так и прямо в параметре функции или процедуры (см. Пример 2 и Пример 3).
<br><br>

<b>Таблица #2 - Перечень математических операций</b><br>
</p>

<table border=1 cellspacing=0 cellpadding=3>
<tr><td class="head">Операция</td><td class="head">Приоритет</td><td class="head">Пример</td></tr>
<tr><td>Скобки приоритета "<b>( )</b>"</td><td>1</td><td>$var = (1 + 2) * 2</td></tr>
<tr><td>Умножение "<b>*</b>"</td><td>2</td><td>$var = 1 * 2</td></tr>
<tr><td>Деление "<b>/</b>"</td><td>2</td><td>$var = 1 / 2</td></tr>
<tr><td>Сложение "<b>+</b>"</td><td>3</td><td>$var = 1 + 2</td></tr>
<tr><td>Вычитание "<b>-</b>"</td><td>3</td><td>$var = 1 - 2</td></tr>
</table>



<a name="LOGIC"></a><p class="subtitle">УСЛОВИЯ, СРАВНЕНИЯ, ЛОГИЧЕСКИЕ ОПЕРАЦИИ</p>
<p>
Условия являются мозгом любого "умного" алгоритма, подразумевающего некие действия в зависимости от сложившейся ситуации. В языке сценариев за это отвечает условная конструкция <b class="func_name">if</b>(). В отличие от математических вычислений, логические вычисления в конечном итоге всегда дают один из двух результатов: истину, если условие соответствует действительности, и ложь, если условие не соответствует. Обычно их сопостовляют с числами 1 и 0 соответственно. Типичный пример простейшего логического выражения - это сравнение двух значений. Рассмотрим очередной пример простейшего условия.
</p>

<b>Пример #4</b>
<pre>
// генерация случайного числа
$var = rnd(1, 10)

// проверка условия
if ($var > 5)
  print($var, " > 5" )
end_if
</pre>

<p>
Во второй строчке переменной <i class="par_num">$var</i> присваивается случайное число от 1 до 10. На шестой строчке начинается условная констркция, в заголовке которой присутствует условие выполнения - логическое выражение <i class="par_num">$var > 5</i>. В том случае если в момент выполнения это условие будет истинно (в <i class="par_num">$var</i> будет число от 6 до 10), то внутренний код условия выполнится, в лог будет выведено сообщение. В случае если условие будет ложно, то ничего не произойдет. Хотя "ложный" исход так же можно обрабатывать при помощи блока <b class="func_name">else</b> логической конструкции <b class="func_name">if</b>(). Об этом написано в соответствующем разделе справки. Следующая таблица содержит все доступные операции сравнения.
<br><br>
<b>Таблица #4 - Перечень операций сравнения</b><br>
</p>

<table border=1 cellspacing=0 cellpadding=3>
<tr><td class="head">Операция</td><td class="head">Синтаксис</td></tr>
<tr><td>Больше </td><td>></td></tr>
<tr><td>Меньше </td><td><</td></tr>
<tr><td>Равно </td><td>==; =</td></tr>
<tr><td>Неравно </td><td>!=; !</td></tr>
<tr><td>Больше или равно </td><td>>=</td></tr>
<tr><td>Меньше или равно </td><td><=</td></tr>
</table>
</p>

<p>
При этом зачастую не всегда можно обойтись одной операцией сравнения. Иногда нужно проверить сразу два условия, причем сразу. Для этого используются логические операции, позволяющие составлять сложные условия. Как и операции сравнения, они объединяют два операнда и их результатом в рамках конструкции <b class="func_name">if</b>() будет либо истина либо ложь.<br>
Всего таких операций три. И, ИЛИ, ИСКЛЮЧАЮЩЕЕ ИЛИ. Логическое И возвращает истину когда оба операнда истинны. Если же хоть один из них будет ложным, то все выражение становится ложным. Логическое ИЛИ возвращает истину когда хоть один операнд истинный. Ложь будет возвращена только если оба операнда ложны. Логическое исключающее ИЛИ вернет истину когда только один операнд соответствует истине. При этом ложь будет возвращена и в случае когда сразу оба операнда ложны, и в случае когда они оба истинны.
<br><br>

<b>Таблица #5 - Перечень логических операций</b><br>
</p>

<table border=1 cellspacing=0 cellpadding=3>
<tr><td class="head">Операция</td><td class="head">Синтаксис</td></tr>
<tr><td>Логическое И </td><td>and; &</td></tr>
<tr><td>Логическое ИЛИ </td><td>or; |</td></tr>
<tr><td>Логическое исключающее ИЛИ </td><td>xor; ^</td></tr>
</table>



<p>
Рассмотрим несколько примеров для понимания.
<br><br>

<b>Пример #5</b>
<pre>
// условие 1
if ((5 > 3) and (3 > 5))
  print("истина")
else
  print("ложь")
end_if

// условие 2
if ((5 > 3) or (3 > 5))
  print("истина")
else
  print("ложь")
end_if


// условие 3
if ( ((5 > 3) and (3 > 5)) or (5 > 3) )
  print("истина")
else
  print("ложь")
end_if
</pre>

Разумеется, как и в Примере №4, здесь могли бы использоваться не только простые числа, но и переменные, функции и т.п. Но для обучения азам более наглядны будут простые числа 3 и 5. Обратите внимание, что в этом примере в конструкции if() добавлен блок else.<br>

Итак, первое условие даст в итоге ложь потому что не все операнды истинны. Обратите внимание на второе сравнение (3 > 5). Совершенно очевидно, что это утверждение ложно. А значит и все выражение так же будет ложно, потому что используется логическое И. Второе условие похоже на первое, за тем исключением, что там используется более "лояльное" логическое ИЛИ. И поскольку как минимум одно сравнение дает истину (5 > 3), то этого становитс ядостаточно чтоб все выражение стало истинным. Третье условие просто демонстрирует, что в особо сложных случаях можно задействовать скобки приоритета. Здесь, в условиях, они выполняют ту же роль, что и в простой математике. Главное не запутаться в них. 
</p>





<a name="ARRAY"></a><p class="subtitle">МАССИВЫ</p>

<p>
Массивы по сути это наборы все тех же переменных, однако объединенные общим именем. При этом каждый элемент массива имеет свой поряковый номер, называемый индексем. Индексация элементов массива начинается с нуля. Как и переменные, элементы массива могут использоваться в качестве аргументов или членов выражений. Кроме того, существуют специальные функции для работы исключительно с массивами. К примеру процедура <b class="func_name">tfreadarr</b>()<br>, считывающая текстовый файл, помещая каждую его строку в отдельный элемент массива.<br>
Работа с массивами отличается от работы с переменными только тем, что в синтаксисе после имени массива присутствуют квадратные скобки, содержащие индекс, который в свою очередь может быть как обычным числом, так и вычисляемой переменной. Как правило, работа с массивами плотно пересекается с циклами. Поэтому необходимо изучить и эту несложную тему.
<br><br>

<b>Пример #6</b>
<pre>
// массив из трех элементов
$var[0] = 1
$var[1] = 2
$var[2] = 3

// накапливаемая сумма
$result = 0 

// перебор через цикл элементов массива [0 .. 2]
for($i = 0, $i < 3)
  $result = $result + $var[ $i ]
end_cyc

// вывод суммы элементов
print( $result )
</pre>

Данный пример считает сумму элементов массива. Первые три строчки очень просты. В них трем элементам массива $var присваиваются значения. На самом деле в реальной жизни так делают крайне редко, и здесь этот способ приведен скорее для упрощения примера. Вся магия начинается в цикле for(). Возможно новичку он покажется жутковатым, однако все что он делает - это просто выполняет свое тело, увеличивая при этом свою переменную $i, которая и используется в качестве индекса массива. То есть цикл перебирает один элемент массива за другим и считает общую сумму в переменной $result.
<br>
Более полно и детально работа с массивами рассмотрена <a href="http://crapware.aidf.org/forum/index.php?topic=319.0" target=_blank>в соответствующей теме</a> на официальном форуме. 
</p>


<a name="CONST"></a><p class="subtitle">КОНСТАНТЫ</p>
<p>
Константы играют ту же роль, что и переменные. За тем исключением, что константы нельзя изменить и их префикс "#".<br>
Константы загружаются в программу при запуске из файла <b>%Clickermann%/data/const.txt</b><br>
Вы можете его править, однако тогда не забывайте делать его копию при скачивании новой версии ПО.
</p>


<a name="PREP"></a><p class="subtitle">ДИРЕКТИВЫ ПРЕПРОЦЕССОРА</p>

<p>
Это страшное для неподготовленного человека определение означает ряд команд, которые выполняются только в момент загрузки скрипта и в дальнейшем в работе не участвуют.
</p>

<table border=1 cellspacing=0 cellpadding=3 width=100%>
<tr><td>Директива</td><td>Значение</td><td>Пример</td></tr>
<tr><td>#name</td><td>Позволяет задать скрипту имя, которое будет отображаться рядом с названием программы.</td><td>#name "СуперБот v1.2"</td></tr>
<tr><td>#include</td><td>Вставляет в это место содержимое текстового файла из папки проекта. Это позволяет "прятать" объемный код, повышая таким образом читаемость скрипта.</td><td>#include "mylib.cms"</td></tr>
<tr><td>#logfile</td><td>Включает ведение лог-файла в папке проекта, куда дублируется весь вывод через logwrite / print</td><td>#logfile "debug.txt"</td></tr>
<tr><td>#autorun</td><td>Сценарий начинает выполняться сразу после загрузки</td><td>#autorun</td></tr>
<tr><td>#ps2_keyboard</td><td>Включает режим PS/2 клавиатуры</td><td>#ps2_keyboard</td></tr>
<tr><td>#ps2_mouse</td><td>Включает режим PS/2 мыши</td><td>#ps2_mouse</td></tr>
<tr><td>#define</td><td>Заменяет один текст на другой</td><td>#define <искомое>:<новое></td></tr>
</table>



<a name="EX"></a><p class="subtitle">ПРОЧИЕ ОСОБЕННОСТИ</p>
<p>
<b>Шестнадцатиричная запись</b><br>
Помимо обычного способа написания числа, вы можете использовать шестнадцатиричную запись. К примеру, число 255 в такой записи будет выглядеть как 0xFF, а 2018 - как 0x07E2. При этом префикс "0x" является обязательным и неизменным. Этот способ особенно подходит для работы с адресами в памяти. Таким образом можно записывать только целые положительные числа.
</p>

<!--
<b>Разнотипные данные</b><br>
Всегда стоит помнить, что несмотря на весьма большую лояльность к приведению типов, кликер не может понять суть вашего кода. Поэтому иногда (обычно в условных конструкциях и при переприсвоении) требуется принудительное приведение типов через специальные функции приведения <b class="func_name">int</b>(), <b class="func_name">num</b>(), <b class="func_name">str</b>(). Рассмотрим простейший пример 

<b>Пример #7</b>
<pre>
$var1 = "5"
$var2 = "10"

if ($var1 < $var2)
  print("true")
end_if
</pre>

Совершенно очевидно, что 10 больше чем 5, и, соответственно, $var2 больше чем $var1. Однако, обе переменные являются строковыми (содержат строку, а не число). В результате в условие попадают две строки, а кликер не сможет понять что значит "строка1 больше чем строка2". Еще более коварная ситуация возникает, когда строку возвращает одна из строковых функций. а программист позабыл ее тип.<br>
Чтобы данный код выполнился так, как задумывалось, необходимо представить в условии оба значения как численные. Для этого просто воспользуемся функцией <b class="func_name">num</b>() для принудительного приведения к численному типу.

<b>Пример #8</b>
<pre>
$var1 = "5"
$var2 = "10"

if (num($var1) < num($var2))
  print("true")
end_if
</pre>

Ньюансы работы с разнотипными данными необходимо всегда держать в голове, потому они могут порождать скрытые ошибки, на которые не будет ругается кликер, а вы потратите много времени на поиск.
</p>
-->
