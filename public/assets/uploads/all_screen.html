<!-- last edit 23.01.18 -->

<link href="style.css" rel="stylesheet" type="text/css">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />

<p class="title">Процедуры и функции для работы с экраном</p>

<p>
Экран состоит представляет собой прямоугольник, состоящий из точек-пикселей. Размеры (ширина и высота) этого прямоугольника
обусловлены количеством пикселей в вертикальной и горизонтальной строках. Каждый пиксель на экране имеет свои координаты. В общем все как на уроке геометрии.<br>
В левом верхнем углу находится пиксель с координатами 0,0. Соответственно, если у вас разрешение экрана 800х600, то нижний правый пиксель будет иметь координаты 799х599.<br>
Помимо координат, каждый пиксель имеет свой собственный цвет свечения, образуемый тремя каналами - красным, зеленым и синим. Эти три канала для удобства кодируются в одно число. Это число и представляет собой цвет пикселя.<br>
Для гибкости и удобства кликер работает не с живым экраном, а с его снимком, помещенным в буфер анализа. Это позволяет во первых ускорить работу, во вторых - наделить программу
неким подобием зрительной памяти. Одновременно в памяти может храниться только один снимок экрана.
</p>


<p class="title">Содержание</p>

<ul>
<li><a href=#GETSCREEN>GETSCREEN</a>
<li><a href=#PXL>PXL</a>
<li><a href=#PXLCOUNT>PXLCOUNT</a>
<li><a href=#PXLXOR>PXLXOR</a>
<li><a href=#PXLCRC>PXLCRC</a>
<li><a href=#PXLREPLACE>PXLREPLACE</a>
<li><a href=#IF_PIXEL_IN>IF_PIXEL_IN ... END_IF</a>
<li><a href=#IF_PICTURE_IN>IF_PICTURE_IN... END_IF</a>
<li><a href=#SCANPICTURE>SCANPICTURE</a>
<li><a href=#SCANPXL>SCANPXL</a>
<li><a href=#SCREENSHOT>SCREENSHOT</a>
<li><a href=#SCREENSHOTEX>SCREENSHOTEX</a>
<li><a href=#SCREENSHOTFIX>SCREENSHOTFIX</a>
<li><a href=#COLORMODE>COLORMODE</a>
<li><a href=#COLORGEN>COLORGEN</a>
<li><a href=#COLORRGB>COLORR, COLORG, COLORB</a>



</ul>

<a name="GETSCREEN"></a><p class="subtitle">GETSCREEN</p>
<p>Делает снимок экрана и помещает его в буфер анализа программы.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">GETSCREEN</b> ([<i class="par_num">x1</i>, <i class="par_num">y1</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x1, y1, x2, y2</i> - параметры, описывающие область экрана; необязательны<br>
</p>

<br>

<b>Описание</b>
<p>
Данная процедура помещает снимок экрана в буфер программы. Затем, из этого буфера берут данные все графические функции, вызываемые в сценарии. Соответственно, в случае когда необходимо обновить хранящееся в памяти состояние экрана, нужно вызвать <b class="func_name">getscreen</b>() еще раз.<br>
В случае, если указаны параметры, описывающие область, будет обновлена только соответствующая область в графическом буфере. На некоторых системах это позволяет ускорить выполнение данной инструкции.
</p>


<a name="PXL"></a><p class="subtitle">PXL</p>
<p>Функция. Возвращает код цвета для заданного пикселя.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">PXL</b> (<i class="par_num">x</i>, <i class="par_num">y</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x, y</i> - координаты пикселя
</p>

<br>

<b>Пример</b>
<p>
<pre>
$clr = PXL(50,50)
</pre>
</p>



<a name="PXLCOUNT"></a><p class="subtitle">PXLCOUNT</p>
<p>Функция. Производит подсчет количества пикселей заданного цвета в прямоугольной области буфера анализа.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">PXLCOUNT</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_num">color</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
<i class="par_num">color</i> - код цвета
</p>

<b>Пример</b>
<pre>
GETSCREEN
$count = PXLCOUNT (10,20, 100, 40, 255)
logwrite("pixels: ", $count)
</pre>

<br>

<b>Примечания</b>
<p>
Если ни одного пикселя не будет найдено, функция вернет ноль
</p>



<a name="PXLXOR"></a><p class="subtitle">PXLXOR</p>
<p>Функция. Производит подсчет контрольной суммы пикселей в заданной области, складывая их цвета оператором XOR.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">PXLXOR</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
</p>

<br>

<b>Пример</b>
<pre>
GETSCREEN
$count = PXLXOR (10,20, 100, 40)
logwrite("Hash: ", $count)
</pre>

<br>

<b>Примечания</b>
<p>
Необходимо понимать что контрольная сумма используется для характеристики области экрана. То есть если была подсчитана сумма, в области изменился хотя бы один пиксель и если подсчитать сумму снова - она будет отличаться от первой. Такой способ не очень надежен в плане получения уникального хеша для простых изображений, но весьма быстр.
</p>


<a name="PXLCRC"></a><p class="subtitle">PXLCRC</p>
<p>Функция. Производит подсчет контрольной суммы пикселей в заданной области, используя алгоритм CRC32.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">PXLCRC</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
</p>

<br>

<b>Пример</b>
<pre>
GETSCREEN
$count = PXLCRC (10,20, 100, 40)
logwrite("Hash: ", $count)
</pre>

<br>

<b>Примечания</b>
<p>
Более актуальный метод подсчета хеша для области экрана. Лишен недостатков <b class="func_name">PXLXOR</b>(), хотя работает примерно в два раза медленнее
</p>


<a name="PXLREPLACE"></a><p class="subtitle">PXLREPLACE</p>
<p>Производит замену в области графического буфера пикселей одного цвета на пиксели другого цвета.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">PXLREPLACE</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_num">color</i>, <i class="par_num">newcolor</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области<br>
<i class="par_num">color</i> - заменяемый цвет<br>
<i class="par_num">newcolor</i> - новый цвет<br>


</p>

<br>

<b>Пример</b>
<pre>
GETSCREEN
PXLREPLACE(10,20, 100, 40, -1, 255)
screenshot
</pre>

<br>

<b>Примечания</b>
<p>
Чтобы заменялись пиксели любого цвета, параметр <i class="par_num">color</i> должен быть равен -1
</p>



<a name="IF_PIXEL_IN"></a><p class="subtitle">IF_PIXEL_IN ... END_IF</p>
<p>Производит поиск пикселя заданного цвета в прямоугольной области буфера анализа.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">IF_PIXEL_IN</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_num">color1</i>, <i class="par_num">...</i>)<br>
...<br>
<b class="func_name">END_IF</b><br>

</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
<i class="par_num">color1</i>, <i class="par_num">...</i> - цвета, поиск которых будет осуществляться
</p>

<br>

<b>Возвращаемые параметры</b>
<p>
<i class="par_var">$_return1</i> - x координата найденного пикселя<br>
<i class="par_var">$_return2</i> - y координата<br>
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// поиск красного пикселя
IF_PIXEL_IN (10,20, 100, 40, 255)
 lclick($_return1, $_return2)
END_IF

// поиск красного или зеленого пикселя
IF_PIXEL_IN (10,20, 100, 40, 255, 65280)
 lclick($_return1, $_return2)
END_IF
</pre>

<br>

<b>Примечания</b>
<p>
Как только первый попавшийся пиксель будет найден, инструкция вернет его координаты в переменные <i class="par_var">$_return1</i>, <i class="par_var">$_return2</i> и прекратит анализ<br>
Добавление каждого цвета увеличивает длительность анализа на 100%
</p>


<a name="IF_PICTURE_IN"></a><p class="subtitle">IF_PICTURE_IN ... END_IF</p>
<p>Производит поиск изображения в прямоугольной области буфера анализа.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">IF_PICTURE_IN</b> (<i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_str">file</i>, [<i class="par_num">bgcolor</i>], [<i class="par_num">currency</i>] )<br>
...<br>
<b class="func_name">END_IF</b><br>

</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
<i class="par_str">file</i> - bmp файл, поиск которого будет осуществляться<br>
<i class="par_num">bgcolor</i> - необязательный параметр; игнорируемый цвет фона входного изображения<br>
<i class="par_num">currency</i> - необязательный параметр; точность поиска в процентах (1..100)<br>
</p>

<br>

<b>Возвращаемые параметры</b>
<p>
<i class="par_var">$_return1</i> - x координата найденного изображения<br>
<i class="par_var">$_return2</i> - y координата -//-<br>
</p>

<br>

<b>Пример</b>
<pre>
getscreen

IF_PICTURE_IN (10,20, 300, 300, "somefile.bmp")
 move($_return1, $_return2)
END_IF
</pre>

<br>

<b>Примечания</b>
<p>
Работает аналогично IF_PIXEL_IN. Как только первый попавшийся участок будет найден, инструкция вернет его координаты в переменные <i class="par_var">$_return1</i>, <i class="par_var">$_return2</i> (координаты верхнего левого угла) и прекратит анализ.<br>
Для того что бы участок признался подходящим, необходимо 100% соответствие пикселей bmp-файла и текущего снимка экрана. Так же можно задать цвет фона изображения, который не будет учитываться при поиске на экране. Если цвет фона не задан, изображение ищется с учетом всех пикселей. <br>
Можно задать не 100% совпадение. Для этого укажите в параметре <i class="par_num">currency</i> необходимую точность. Этот параметр определяет количество несовпавших пикселей, которые будут проигнорированы при анализе. Чем ниже значение точности, тем дольше идет поиск.<br>
Если параметр <i class="par_num">currency</i> не задан, по умолчанию он равен 100. Если параметр <i class="par_num">bgcolor</i> не задан, по умолчанию он равен -1. Если есть необходимость задать точность, не задавая фон, сделайте <i class="par_num">bgcolor</i> равным -1.<br>
Входные файлы для анализа должны находиться в директории проекта, быть формта BMP и иметь стандартную разрядность 24 бита. В случае использования цветокоррекции, входной файл должен быть уже откорректирован. Чтобы добиться этого результата, сохраните скриншот формата bmp после вызова <b class="func_name">colormode</b>(), затем вырежьте нужный участок картинки в графическом редакторе и сохраните как bmp.
</p>


<a name="SCANPICTURE"></a><p class="subtitle">SCANPICTURE</p>
<p>Производит поиск изображения в прямоугольной области буфера анализа и выводит координаты найденных экземпляров в массив.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">SCANPICTURE</b> (<i class="par_var">$var</i>, <i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_str">file</i>, [<i class="par_num">bgcolor</i>], [<i class="par_num">currency</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_var">$var</i> - массив<br>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
<i class="par_str">file</i> - bmp файл, поиск которого будет осуществляться<br>
<i class="par_num">bgcolor</i> - необязательный параметр; игнорируемый цвет фона входного изображения<br>
<i class="par_num">currency</i> - необязательный параметр; точность поиска в процентах (1..100)<br>
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// поиск изображения pict.bmp в области 0,0 - 1250,959
scanpicture($var, 0,0, 1250,959, "pict.bmp")

// вывод массива, содержащего результаты поиска
while (arrsize($var) > 0)
  $y = arrpop($var)
  $x = arrpop($var)
  print($x,":", $y)
end_cyc
</pre>

<br>

<b>Примечания</b>
<p>
Основные параметры и тонкости работы аналогичны <b class="func_name">IF_PICTURE_IN</b><br>
Результатом работы является массив $var, в который добавляются координаты найденных экземпляров изображения. Таким образом, координаты первого найденного изображения будут лежать в $var[0] и $var[1] для X и Y соответственно. Для второго экземпляра $var[2] и $var[3] и т.д.
<br>
<b class="func_name">SCANPICTURE</b> и <b class="func_name">SCANPXL</b> используют в своей работе массивы. Если вам не понятна работа с массивами, то прочтите учебную статью на <a href="http://crapware.aidf.org/forum/" target=_blank>официальном форуме</a> в разделе "Учебные статьи".
</p>



<a name="SCANPXL"></a><p class="subtitle">SCANPXL</p>
<p>Производит поиск пикселей заданного цвета в прямоугольной области буфера анализа.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">SCANPXL</b> (<i class="par_var">$var</i>, <i class="par_num">x</i>, <i class="par_num">y</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_num">color</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_var">$var</i> - принимающий массив<br>
<i class="par_num">x</i>, <i class="par_num">y</i> - числовые координаты левого верхнего угла области поиска<br>
<i class="par_num">x2</i>, <i class="par_num">y2</i> - числовые координаты правого нижнего угла области поиска<br>
<i class="par_num">color</i> - цвет, поиск которого будет осуществляться
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// поиск всех красный (255) пикселей в области 0,0 - 1250,959
scanpxl($var, 0,0, 1250,959, 255)

// вывод массива, содержащего результаты поиска
while (arrsize($var) > 0)
  $y = arrpop($var)
  $x = arrpop($var)
  print($x,":", $y)
end_cyc
</pre>

<br>

<b>Примечания</b>
<p>
Результатом работы является массив $var, в который добавляются координаты найденных пикселей заданного цвета. Таким образом, координаты первого найденного пикселя будут лежать в $var[0] и $var[1] для X и Y соответственно. Для второго экземпляра $var[2] и $var[3] и т.д.
</p>


<a name="SCREENSHOT"></a><p class="subtitle">SCREENSHOT</p>
<p>Сохраняет графический буфер анализа на диск.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">SCREENSHOT</b> ([<i class="par_str">pref</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_str">pref</i> - необязательный параметр; префикс для названия файла
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// будут созданы скриншоты error0000.bmp, error0001.bmp, error0002.bmp, 
screenshot("error")
screenshot("error")
screenshot("error")

// будет создан скриншот shot0000.bmp
screenshot
</pre>

<br>

<b>Примечания</b>
<p>
Скриншот экрана помещается в директорию текущено скрипта в каталог <b>screens</b> и ему присваивается имя вида
pref0000.bmp. При этом номер 0000 будет наращиваться по мере необходимости<br>
Если параметр <i class="par_str">pref</i> опущен, он считается равным "shot". В случае использования оконного режима будет сделан скриншот только рабочей области.
</p>


<a name="SCREENSHOTEX"></a><p class="subtitle">SCREENSHOTEX</p>
<p>Сохраняет часть графического буфера анализа на диск.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">SCREENSHOTEX</b> (<i class="par_num">x1</i>, <i class="par_num">y1</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, [<i class="par_str">pref</i>], [<i class="par_str">format</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x1, y1, x2, y2</i> - четыре координаты, описывающие сохраняемую область буфера<br>
<i class="par_str">pref</i> - необязательный параметр; префикс названия<br>
<i class="par_num">format</i> - необязательный параметр; тип файла (сжатие): 0 - bmp; 1 - jpeg
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// будет создан скриншот небольшого кусочка левого верхнего угла
screenshotex(10,10, 50,50)
</pre>

<br>

<b>Примечания</b>
<p>
Скриншот экрана помещается в директорию текущено скрипта в каталог <b>screens</b> и ему присваивается имя вида
pref0000.bmp. При этом номер 0000 будет наращиваться по мере необходимости.<br>
Если параметр <i class="par_str">pref</i> опущен, он считается равным "shot". В случае использования оконного режима скриншот будет вырезан из привязанной рабочей области.
</p>

<a name="SCREENSHOTFIX"></a><p class="subtitle">SCREENSHOTFIX</p>
<p>Сохраняет часть графического буфера анализа на диск в конкретный файл.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">SCREENSHOTFIX</b> (<i class="par_num">x1</i>, <i class="par_num">y1</i>, <i class="par_num">x2</i>, <i class="par_num">y2</i>, <i class="par_str">path</i>, [<i class="par_num">format</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">x1, y1, x2, y2</i> - четыре координаты, описывающие сохраняемую область буфера<br>
<i class="par_str">path</i> - путь, по которому будет сохранен скриншот<br>
<i class="par_num">format</i> - необязательный параметр; тип файла (сжатие): 0 - bmp; 1 - jpeg
</p>

<br>

<b>Пример</b>
<pre>
getscreen

// будет создан скриншот небольшого кусочка левого верхнего угла
screenshotfix(10,10, 50,50, "D:\file.bmp")
</pre>

<br>

<b>Примечания</b>
<p>
В отличие от <b class="func_name">SCREENSHOTEX</b>, файл сохраняется в конкретное место по относительному или абсолютному пути, каждый раз перезаписываясь. Расширение файла желательно задавать исходя из параметра <i class="par_num">format</i> (по умолчанию 0).
</p>


<a name="COLORMODE"></a><p class="subtitle">COLORMODE</p>
<p>Применяет цветокоррекцию к текущему снимку экрана.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">COLORMODE</b> (<i class="par_num">mode</i>, [<i class="par_num">x1, y1, x2, y2</i>] )
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">mode</i> - число, соответствующее режиму коррекции<br>
<i class="par_num">x1, y1, x2, y2</i> - область снимка экрана, к которой будет применена коррекция<br>
</p>

<br>


<b>Описаие</b>
<p>
Процедура изменяет текущий снимок экрана, применяя к нему фильтр, снижающий количество цветов в палитре. В основной справке есть статья посвещенная цветокоррекции.<br>
Есть возможность указать отдельную область для применения фильтра. Стоит учитывать, что на его применение так же затрачивается время, поэтому если нет необходимости менять весь снимок, указание конкретной области позволит выиграть немного времени в процессе выполнения сценария. Если область не описана, коррекция применяется ко всему экрану<br>
Вызов <b class="func_name">COLORMODE</b>(0) не имеет смысла. Поддерживается одностороннее увеличение режима (1, 2, 3..) без необходимости повторного вызова <b class="func_name">GETSCREEN</b>. Обратно увеличить количество цветов невозможно. Новый "чистый" снимок экрана получается новым вызовом <b class="func_name">GETSCREEN</b>
</p>

<br>


<b>Таблица значений mode</b>
<p>
<table border=0>
<tr><td width=50><i>mode</i><td><i>Макс. цветов</i></tr>
<tr><td>0<td>16 777 216
<tr><td>1<td>2 097 152
<tr><td>2<td>262 144
<tr><td>3<td>32 768
<tr><td>4<td>4 096
<tr><td>5<td>512
<tr><td>6<td>64
<tr><td>7<td>8
<tr><td>8<td>2
</table>
</p>



<a name="COLORGEN"></a><p class="subtitle">COLORGEN</p>
<p>Функция. Генерирует код цвета путем соединения значений красного, зеленого и синего каналов.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">COLORGEN</b> (<i class="par_num">red</i>, <i class="par_num">green</i>, <i class="par_num">blue</i>)
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">red</i> - значение красного канала (0..255)
<i class="par_num">green</i> - значение зеленого канала (0..255)
<i class="par_num">blue</i> - значение синего канала (0..255)
</p>

<br>

<b>Пример</b>
<pre>
// создаем цвет
$c = colorgen(234,34,65)

// и разбираем его по каналам
print("red: ", colorR($c) ) // красный
print("grn: ", colorG($c) ) // зеленый
print("blu: ", colorB($c) ) // синий
</pre>



<a name="COLORRGB"></a><p class="subtitle">COLORR, COLORG, COLORB</p>
<p>Функции. Извлекают из цвета значение красного (зеленого) (синего) канала.</p>

<b>Синтаксис</b><br>
<p>
<b class="func_name">COLORR</b> (<i class="par_num">color</i>)<br>
<b class="func_name">COLORG</b> (<i class="par_num">color</i>)<br>
<b class="func_name">COLORB</b> (<i class="par_num">color</i>)<br>
</p>

<br>

<b>Параметры</b>
<p>
<i class="par_num">color</i> - код цвета
</p>

<br>

<b>Пример</b>
<pre>
// хватаем произвольный пиксель с экрана
getscreen
$p = pxl(rnd(0,300), rnd(0,300))

// и разбираем его по цветам
print("R:", colorR($p) )
print("G:", colorG($p) )
print("B:", colorB($p) )
</pre>

